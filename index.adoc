= Go Study Notes
Author whoyiming <whoyiming@outlook.com>
:doctype: book
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectnums:
:sectid:
:icons: font

[preface]
== 引言

此文档是关于学习Go语言所做的笔记，方便后续复习，温故而知新。

== Go 语言简介

=== 什么是Go

Go是由 Google 主导开发的静态类型、编译型编程语言，于 2009 年开源，设计目标是解决大型软件开发中的效率、复杂度与并发难题，核心哲学是 “简洁、高效、实用”。

** 极简设计：语法精简，移除冗余特性（如继承、复杂泛型早期缺失），用 “组合” 替代 “继承”，代码可读性高，学习成本低（例如强制统一格式的go fmt工具，避免风格争议）。

** 高性能：编译为机器码，执行效率接近 C 语言，远超解释型语言（如 Python）；启动速度极快（毫秒级），内存占用低，适合高性能服务场景。

** 原生并发：通过goroutine（轻量级线程，开销仅为操作系统线程的 1/100~1/10，单机可轻松创建百万级并发）和channel（通信管道）简化并发编程，从语言层面解决多核时代的并发难题。

** 平衡开发效率与可靠性：静态类型确保编译时错误检查（比动态语言更可靠），同时内置垃圾回收（GC）避免手动内存管理（比 C/C++ 更高效），开发效率接近动态语言。

=== Go 与 Java Python 的对比及其生态与场景

|===
| 维度       | Go                             | Java                             | Python                             
| 执行方式   | 编译型（直接生成机器码）| 编译型（字节码，依赖 JVM）| 解释型（依赖 Python 解释器）
| 启动速度   | 极快（毫秒级，单一二进制文件）| 较慢（JVM 预热耗时，秒级）| 中等（解释器启动快，但执行慢）
| 运行时性能 | 接近 C（CPU 密集型表现优异）| 优秀（JIT 优化后接近原生）| 较差（解释执行，比前两者慢 10-100 倍）
| 内存占用   | 低（无 JVM overhead）| 中高（JVM 本身占用内存）| 中（解释器 + 动态类型开销）
|===

|===
| 领域           | Go 擅长                                  | Java 擅长                                  | Python 擅长                                  
| 云原生 / 分布式 | Docker、K8s、Etcd、微服务                 | 分布式框架（Dubbo、Spring Cloud）| 边缘脚本、监控工具                           
| 企业级应用     | 轻量微服务（如字节跳动推荐系统）| 大型业务系统（银行、电商核心系统）| 内部工具、数据分析后台                       
| 移动开发       | 跨平台工具（如 Flutter 引擎）| 安卓应用（官方开发语言）| 无（仅辅助脚本）
| 数据科学 / AI  | 高性能计算引擎（如 TensorFlow 部分模块）| 机器学习框架（如 H2O）| 数据分析（Pandas）、AI（PyTorch/TensorFlow） 
| 工具开发       | 命令行工具（Terraform、Prometheus）| 企业级工具（Jenkins）| 自动化脚本、爬虫                             
|===

=== Go的前世今生

学习一门语言，要了解其前世今生，历史与现状，才能对一门语言有更加深入的理解。了解Go 语言是怎么诞生的，就能清晰知道Go 是为了解决什么问题，了解现状，就能知道语言发展经历到了什么阶段，能解决多大的问题。

Go 语言的创始人有三位，分别是图灵奖获得者、C 语法联合发明人、Unix 之父肯·汤普森（Ken Thompson），Plan 9 操作系统领导者、UTF-8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）。

image::images/93e91ef659a99c1e37d1fd54a8655375.webp[title="Go语言之父们（从左到右分别是Robert Griesemer、Rob Pike和Ken Thompson）"]

Go 诞生于一次研讨，三位大牛交换了关于设计一门新编程语言的想法。

当时，他们在谷歌内部使用的是 +++ C++ +++ 语言来构建各种系统，但 +++ C++ +++ 有着巨大的复杂性、编译构建慢、编写服务端不容易且对并发支持不足。三位大牛都觉得不方便，随即一拍即合，有了设计新语言的想法。新语言需要有简洁、高效、让人使用方便，且满足未来硬件发展趋势和大规模网络服务的程序。由此，Go语言的雏形便出现。随着三人想法的落地，再到社区运营更多人的参与，现在Go语言已经是一门在云原生、网络、企业级应用等方面有着足够竞争力的语言。同时，Go语言也在不断加入新特性，保证语言的活力。

== Go 环境配置

以下是windows环境安装Go语言。

访问 https://golang.google.cn/ （有可能打不开） 或者 https://go.dev/dl/ 。找到windows的包，下载安装版，在弹出的对话框中选择合适的目录进行安装。

image::images/2025-11-22-110052.png[]

如装在 C:\Go\Go1.25.4 ，其结构是

image:images/2025-11-22-110735.png[]

在终端中输入 go version 得到 go version go1.25.4 windows/amd64 ，便安装成功。

image:images/2025-11-23-102458.png[]

[CAUTION]
安装成功后，要重新启动终端，系统中设置的环境变量才会生效

== helloworld

创建一个文件夹 gocodes 写的代码。进入 gocodes，创建一个fisrtgo的文件夹，用于写第一个Go语言代码，进入firstgo，再创建一个hello.go的文件，用记事本打开，输入

[source, Go]
```
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
```

在终端上运行go run hello.go 得到 ** Hello, World!**

image:images/2025-11-23-101522.png[]

=== 基本程序结构

* package main   // 包，表面代码所在的模块（包），通常使用单个的小写字母命名。main包在Go中是一个特殊的包，整个 Go 程序中仅允许存在一个名为 main 的包。
* import "fmt"  // import引入fmt包，fmt 包实现了格式化 IO（输入/输出）的函数。
* func main()  // 程序开始执行的函数，函数内容用大括号包裹。当运行一个可执行的Go程序的时候，所有代码从此此处开始。
* fmt.Println("Hello, World!") // 使用fmt.Println方法，进行输出。

=== 与java的对比

|===
| 对比维度 | Go 语言（基于示例代码） | Java 语言（对应 Hello World 实现）

| 完整代码示例
| [source,go]
----
package main

import "fmt"

func main() {
    fmt.Println("hello, world")
}
----
| [source,java]
----
// 若声明包，需与目录结构一致（示例省略包声明）
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello, world");
    }
}
----

| 包声明规则
| 入口程序必须声明为 `package main`（固定要求），非入口包可自定义包名
| 包声明可选（无包声明则为默认包），**公共类名必须与文件名一致**（大小写敏感）

| 导入语句
| 直接导入依赖包路径（如 `import "fmt"`），支持批量导入（用 `()` 包裹多个包）
| 导入格式为 `import 包路径`（如 `import java.util.List`），`java.lang` 包（含 `System`）默认导入，无需显式声明

| 程序入口
| 入口是 `main` 包下的 `main()` 函数：
- 无参数、无返回值
- 无需修饰符（默认可见性）
| 入口是 **公共类** 下的 `main` 静态方法：
- 必须是 `public static void main(String[] args)`
- 需通过类名关联（运行时指定类名）

| 输出方式
| 使用标准库 `fmt` 包的 `Println()` 函数（格式化输出常用）
| 使用 `System.out.println()`（`System` 是 `java.lang` 包的类，`out` 是静态成员，`println()` 是实例方法）

| 编译与运行机制
| 1. 编译：`go build` 生成 **原生二进制文件**（跨平台需指定 `GOOS`/`GOARCH`）
2. 运行：直接执行二进制文件，或 `go run` 一键编译运行
| 1. 编译：`javac` 生成 `.class` 字节码文件
2. 运行：`java 类名` 由 JVM 解释字节码（跨平台依赖 JVM）

| 语法简洁性
| 无类、接口等面向对象语法，样板代码极少（仅3行核心逻辑）
| 必须用类包裹代码，需显式声明访问修饰符（`public`）和静态修饰符（`static`），样板代码较多

|===

- Go 以 **简洁、高效、原生编译** 为核心，弱化面向对象，更注重工程实用性和并发性能；
- Java 以 **强类型、面向对象、跨平台** 为核心，语法严谨，生态成熟，适合需要复杂架构设计的大型应用；
- 从 Hello World 就能看出：Go 追求“少即是多”，Java 追求“规范与扩展性”。

=== 加点复杂度

如果想要打印由终端输入的参数该怎么做呢？

在fisrtgo文件下创建一个printenv.go的文件

[source, Go]
```
package main

import (
	"fmt"
	"os"
)

func main() {
	if len(os.Args) > 1 {
		fmt.Println("Hello", os.Args[1])
	}
}
```

在终端下输入  go run .\printenv.go master

image:images/2025-11-23-111917.png[]

[TIP]
windows会默认隐藏拓展名，因此我们需要设置显示拓展名，如图所示进行设置

image:images/2025-11-22-113000.png[]

== Go 的基础语法

=== 数据类型

|===
| 类型分类       | 具体类型            | 说明

| 数值型         
| int（随系统位数）、int8/16/32/64   
| 有符号整数（int 在 32 位系统是 32 位，64 位系统是 64 位） 

|                
| uint（无符号）、uint8（byte）      
| 无符号整数（byte 是 uint8 的别名） 

|                
| float32、float64                  
| 浮点数（默认用 float64，精度更高），float32的精度约6-7位，float64的精度约 15-17 位

|                
| complex64、complex128             
| 复数（实部+虚部，如 `3+4i`）         

| 布尔型         
| bool                              
| 取值 true/false（不能用 0/1 替代）   

| 字符串         
| string                            
| 不可变字符序列（UTF-8 编码）         

| 字符型         
| rune                              
| Unicode 码点（int32 的别名，用于处理中文等多字节字符） 

|===

[source, Go]
----
package main

import "fmt"

func main() {
    var a int = 10          // 通用整数（随系统）
    var b uint8 = 255       // 无符号8位，最大值255（赋值256会编译错误）
    var c int64 = 9223372036854775807 // int64最大值
    fmt.Println("int:", a, "uint8:", b, "int64:", c) // 输出：int: 10 uint8: 255 int64: 9223372036854775807

    var f1 float32 = 3.1415926 // 32位浮点，精度有限
    f2 := 2.718281828459045    // 短变量声明，默认float64
    fmt.Println("float32:", f1, "float64:", f2) // 输出：float32: 3.1415925 float64: 2.718281828459045
    
    // 注意：浮点数精度问题
    fmt.Println("0.1 + 0.2 =", 0.1+0.2) // 输出：0.1 + 0.2 = 0.30000000000000004（非0.3）

    var c1 complex64 = 3 + 4i    // 32位复数（实部3，虚部4）
    c2 := 5 + 6i                 // 短变量声明，默认complex128
    fmt.Println("complex64:", c1)                // 输出：complex64: (3+4i)
    fmt.Println("实部:", real(c2), "虚部:", imag(c2)) // 输出：实部: 5 虚部: 6

    var b1 bool = true  // 显式声明
    b2 := false         // 短变量声明
    b3 := b1 && b2      // 逻辑与（都真才真）→ false
    b4 := b1 || b2      // 逻辑或（任一真则真）→ true
    b5 := !b1           // 逻辑非（取反）→ false
    
    fmt.Println("b1:", b1, "b2:", b2) // 输出：b1: true b2: false
    fmt.Println("b3 (&&):", b3, "b4 (||):", b4, "b5 (!):", b5) // 输出：b3 (&&): false b4 (||): true b5 (!): false
    
    // 条件判断（常用场景）
    if b1 {
        fmt.Println("b1 is true")
    } else {
        fmt.Println("b1 is false")
    }


    var s1 string = "Hello, Go!" // 双引号定义
	s2 := "Hello\nWorld"         // 支持转义（\n换行）
	s3 := `line1
	line2
	line3` // 反引号多行字符串（不转义）
	s4 := s1 + " " + s2 // 字符串拼接（+号）

	fmt.Println("s1:", s1) // 输出：s1: Hello, Go!
	fmt.Println("s2:", s2) // 输出：s2: Hello
	//      World
	fmt.Println("s3:", s3) // 输出：s3: line1
	//      line2
	//      line3
	fmt.Println("拼接后s4:", s4) // 输出：拼接后s4: Hello, Go! Hello
	//      World
	fmt.Println("s1长度（字节数）:", len(s1))      // 输出：10（每个ASCII字符占1字节）
	fmt.Println("\"Go语言\"长度:", len("Go语言")) // 输出：8（Go占2字节，中文"语""言"各占3字节）
}
----

=== 变量

Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。

声明变量的一般形式是使用 var 关键字：var param type，也可以一次声明多个变量：var param1，param2 type

[source, Go]
```
package main
import "fmt"
func main() {
    var a string = "hello"
    fmt.Println(a)

    var b, c int = 1, 2
    fmt.Println(b, c)
}
```

如果没有显示的为变量赋值，Go 编译器会为变量赋予这个类型的零值：
var a int // a的初值为int类型的零值：0

|===
|内置原生类型 |默认值（零值）

|所有整数类型 
|0

|浮点类型
|0.0

|布尔类型
|false

|字符串类型
|""

|指针、接口、切片、channel、map和函数类型
|nil
|===

变量声明块（block）的语法形式：

[source, Go]
```
var (
    a int = 128
    b int8 = 6
    s string = "hello"
    c rune = 'A'
    t bool = true
)

var (
    a, b, c int = 5, 6, 7
    c, d, e rune = 'C', 'D', 'E'
) 
```

两种变量声明语法糖：

1. 省略类型信息的声明：
* var a, b, c = 12, 'A', "hello"

2. 短变量声明：
[source, Go]
```
a := 12
b := 'A'
c := "hello"

a, b, c := 12, 'A', "hello"
```

=== 常量

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。在程序运行时，不会被修改的量。其定义格式为：const identifier [type] = value。

[source, Go]
```
package main

import "fmt"

func main() {
   const LENGTH int = 20
   const WIDTH int = 15   
   var area int
   const a, b, c = 1, false, "str" 

   area = LENGTH * WIDTH
   fmt.Println("面积为 : ", area)
   
   fmt.Println(a, b, c)   
}
```

== 运算符

=== 算术运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 基础算术运算
	a, b := 10, 3
	fmt.Println("a + b =", a+b)   // 13
	fmt.Println("a - b =", a-b)   // 7
	fmt.Println("a * b =", a*b)   // 30
	fmt.Println("a / b =", a/b)   // 3（整数除法舍弃小数）
	fmt.Println("a % b =", a%b)   // 1（余数）
	fmt.Println("-a % b =", -a%b) // -1（符号与被除数一致）

	// 浮点数运算
	f1, f2 := 10.0, 3.0
	fmt.Println("f1 / f2 =", f1/f2) // 3.3333333333333335

	// 字符串拼接（仅 + 支持）
	s1, s2 := "Go", "Lang"
	fmt.Println("s1 + s2 =", s1+s2) // GoLang

	// 自增自减（只能独立语句，不能赋值）
	i, j := 5, 5
	i++ // 正确：i = 6
	j-- // 正确：j = 4
	// fmt.Println(i++)  // 错误：不能作为表达式使用
	// k := i++          // 错误：不能赋值
	fmt.Println("i =", i, "j =", j) // 6 4
}
----

=== 赋值运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 基础赋值
	var x int = 10
	x = 20
	fmt.Println("x =", x) // 20

	// 复合赋值
	y := 10
	y += 5  // y = 10 + 5 = 15
	y *= 2  // y = 15 * 2 = 30
	y %= 7  // y = 30 % 7 = 2
	fmt.Println("y =", y) // 2

	// 位运算复合赋值
	z := 0b1010 // 10（二进制）
	z <<= 2     // 左移2位 → 0b101000 = 40
	fmt.Printf("z <<= 2 → %d（二进制：%b）\n", z, z) // 40（101000）
}
----

=== 比较运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 数值比较
	m, n := 10, 20
	fmt.Println("m == n?", m == n) // false
	fmt.Println("m < n?", m < n)   // true
	fmt.Println("m >= n?", m >= n) // false

	// 字符串比较（按Unicode码点顺序）
	s1, s2 := "apple", "banana"
	s3 := "apple"
	fmt.Println("s1 == s3?", s1 == s3) // true
	fmt.Println("s1 < s2?", s1 < s2)   // true（'a' 的码点 < 'b'）

	// 布尔值比较
	b1, b2 := true, false
	fmt.Println("b1 != b2?", b1 != b2) // true

	// 指针比较（指向同一变量则相等）
	p1 := &m
	p2 := &m
	p3 := &n
	fmt.Println("p1 == p2?", p1 == p2) // true
	fmt.Println("p1 == p3?", p1 == p3) // false

	// 错误示例：不同类型不能直接比较
	// var num int = 10
	// var f float64 = 10.0
	// fmt.Println(num == f) // 编译错误：int 和 float64 不兼容
}
----

=== 逻辑运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 基础逻辑运算
	a, b := true, false
	fmt.Println("a && b =", a && b) // false（且：都为true才true）
	fmt.Println("a || b =", a || b) // true（或：任一为true则true）
	fmt.Println("!a =", !a)         // false（非：取反）

	// 短路特性演示
	x, y := 10, 20

	// 逻辑与短路：左为false，右表达式（y++）不执行
	if x > 100 && autoincrement(y) > 0 {
		fmt.Println("逻辑与执行")
	}
	fmt.Println("y =", y) // 20（y++未执行）

	// 逻辑或短路：左为true，右表达式（x++）不执行
	if x < 20 || autoincrement(x) > 0 {
		fmt.Println("逻辑或执行")
	}
	fmt.Println("x =", x) // 10（x++未执行）
}

func autoincrement(val int) int {
	return val + 1
}

----

== Go 流程控制

=== if-else 条件语句

[source, Go]
----
package main

import "fmt"

func main() {
	// 示例1：基础if-else
	score := 85
	if score >= 90 {
		fmt.Println("优秀")
	} else if score >= 70 {
		fmt.Println("良好")
	} else {
		fmt.Println("及格/不及格")
	}

	// 示例2：if初始化语句（推荐用法）
	if age := 22; age >= 18 { // age仅在if-else内有效
		fmt.Println("成年")
	} else {
		fmt.Println("未成年")
	}
}
----

=== for 循环

Go 没有while、do-while，所有循环都用for实现，语法灵活，覆盖三种常见场景。

[source, Go]
----
package main

import "fmt"

func main() {
    // 1. 基本的 for 循环 (类似 C/Java)
    sum := 0
    for i := 0; i < 10; i++ {
        sum += i
    }
    fmt.Println("0到9的和是:", sum)

    // 2. 省略初始化和后置语句 (类似 while)
    n := 1
    for n < 100 {
        n *= 2
    }
    fmt.Println("大于100的最小2的幂是:", n)

    // 2. 无限循环 (需要 break 或 return 退出)
    // for {
    //     fmt.Println("这是一个无限循环，请手动停止程序")
    // }
    
    // 3. for range 遍历 (非常常用)
    s := "Go语言"
    for index, char := range s {
        // 注意 index 是字节位置，char 是 rune 类型
        fmt.Printf("在字节位置 %d 的字符是 %c\n", index, char)
    }
}
----

=== switch 分支语句

Go 的 `switch` 非常灵活，它自动为每个 `case` 添加 `break`，匹配逻辑也更强大。

[source, Go]
----
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    // 1. 基本的 switch
    fmt.Print("Go 运行在 ")
    switch os := runtime.GOOS; os {
    case "darwin":
        fmt.Println("OS X.")
    case "linux":
        fmt.Println("Linux.")
    default:
        // os 在这里仍然可见
        fmt.Printf("%s.\n", os)
    }

    // 2. 无表达式的 switch (相当于 if-else)
    t := time.Now()
    switch {
    case t.Hour() < 12:
        fmt.Println("上午好!")
    case t.Hour() < 17:
        fmt.Println("下午好!")
    default:
        fmt.Println("晚上好!")
    }
    
    // 3. case 可以有多个值
    day := "saturday"
    switch day {
    case "saturday", "sunday":
        fmt.Println("是周末！")
    default:
        fmt.Println("是工作日。")
    }

    // 4：fallthrough（穿透）
	num := 2
	switch num {
	case 2:
		fmt.Println("匹配2")
		fallthrough // 强制穿透到下一个case
	case 3:
		fmt.Println("穿透到3") // 会执行
	default:
		fmt.Println("默认")
	}
}
----

=== defer, panic, 和 recover

`defer` 用于延迟执行一个函数调用，通常用于清理资源。`panic` 用于触发一个运行时恐慌（致命错误），而 `recover` 用于捕获这个恐慌，让程序恢复执行。

[source, Go]
----
package main

import "fmt"

func main() {
    // defer 会在函数返回前执行，多个 defer 按后进先出(LIFO)顺序执行
    defer fmt.Println("世界")
    defer fmt.Println("，")
    fmt.Print("你好")
    // 输出将是: 你好，世界

    causePanic()
    fmt.Println("这行不会被执行，因为 panic 导致程序中断")
}

func causePanic() {
    // 使用 defer 和 recover 来捕获 panic
    defer func() {
        // recover() 只有在 defer 的函数中调用才有效
        if r := recover(); r != nil {
            fmt.Println("\n捕获到了一个 panic:", r)
        }
    }()

    fmt.Println("\n准备触发一个 panic")
    // 模拟一个致命错误
    panic("这是一个故意的 panic")
}
----

== 复合数据类型

=== 数组 (Array)

数组是具有固定长度且包含相同类型元素的序列。

[source, Go]
----
package main

import "fmt"

func main() {
    // 声明一个包含5个整数的数组，默认值为0
    var a [5]int
    fmt.Println("空数组:", a)

    // 赋值和访问
    a[4] = 100
    fmt.Println("赋值后:", a)
    fmt.Println("访问 a[4]:", a[4])
    
    // 声明并初始化
    b := [3]int{1, 2, 3}
    fmt.Println("初始化 b:", b)

    // Go 会自动计算数组长度
    c := [...]string{"北京", "上海", "深圳"}
    fmt.Println("城市:", c, "长度:", len(c))
}
----

=== 切片 (Slice)

切片是 Go 中最重要也最常用的数据结构之一。它提供了对数组中元素序列的动态、灵活的视图。与数组不同，切片的长度是可变的。

一个切片有三个核心属性：指针（指向底层数组的第一个元素）、长度（`len`，切片中元素的数量）和容量（`cap`，从切片开始位置到底层数组末尾的元素数量）。

[source, Go]
----
package main

import "fmt"

func main() {
    // 1. 从数组创建切片
    primes := [6]int{2, 3, 5, 7, 11, 13}
    var s []int = primes[1:4] // 从索引1到3(不含4)
    fmt.Println("切片 s:", s, "长度:", len(s), "容量:", cap(s))

    // 2. 使用 make 创建切片
    // 创建一个长度为5，容量为10的切片
    s2 := make([]int, 5, 10) 
    fmt.Println("make 创建的 s2:", s2, "长度:", len(s2), "容量:", cap(s2))

    // 3. 向切片追加元素
    s2 = append(s2, 1)
    fmt.Println("append 后的 s2:", s2, "长度:", len(s2), "容量:", cap(s2))
    
    // 如果超过容量，Go 会分配一个新的、更大的底层数组
    
    // 4. 遍历切片
    for i, v := range s {
        fmt.Printf("s[%d] = %d\n", i, v)
    }
}
----

=== Map

Map 是一个无序的键值对集合，也称为哈希表或字典。

[source, Go]
----
package main

import "fmt"

func main() {
    // 1. 创建 map
    // var m map[string]int // 值为 nil，无法使用
    m := make(map[string]int) // 正确的创建方式

    // 2. 存值
    m["北京"] = 101
    m["上海"] = 102
    
    fmt.Println("Map:", m)
    
    // 3. 取值
    v1 := m["北京"]
    fmt.Println("北京区号:", v1)
    
    // 4. 删除键值对
    delete(m, "上海")
    fmt.Println("删除后:", m)
    
    // 5. 判断键是否存在
    // 如果键不存在，v 会是值的零值(这里是0)，ok 会是 false
    v, ok := m["广州"]
    if ok {
        fmt.Println("广州区号是:", v)
    } else {
        fmt.Println("广州的区号不存在")
    }
}
----

=== 结构体 (Struct)

结构体是一个字段的集合，用于将数据聚合在一起形成新的类型。

[source, Go]
----
package main

import "fmt"

// 定义一个 Person 结构体
type Person struct {
    Name string
    Age  int
}

func main() {
    // 1. 创建结构体实例
    p1 := Person{"小明", 20}
    fmt.Println("p1:", p1)
    
    // 2. 使用字段名创建
    p2 := Person{Name: "小红", Age: 19}
    fmt.Println("p2:", p2)
    
    // 3. 访问字段
    fmt.Println("p2 的名字是:", p2.Name)
    
    // 4. 结构体指针
    p3 := &Person{Name: "小刚", Age: 22}
    // Go 语言很方便，可以直接用 p3.Age 访问，无需像 C++ 那样写 (*p3).Age
    p3.Age++ 
    fmt.Println("小刚明年", p3.Age, "岁")
}
----

== Go 函数

在Go中，函数是“一等公民”，意味着它们可以像任何其他值一样被传递、赋值。

=== 多返回值

Go函数可以返回任意数量的值。这在Go中被广泛用于返回结果和错误信息。

[source, Go]
----
package main

import (
    "fmt"
    "strconv"
)

// stringToInt 将字符串转换为整数，同时返回结果和一个错误信息
func stringToInt(s string) (int, error) {
    i, err := strconv.Atoi(s)
    if err != nil {
        // 如果转换出错，返回0和错误信息
        return 0, fmt.Errorf("转换失败: %v", err)
    }
    // 成功则返回转换后的整数和 nil
    return i, nil
}

func main() {
    val1, err1 := stringToInt("123")
    if err1 != nil {
        fmt.Println(err1)
    } else {
        fmt.Println("成功:", val1)
    }
    
    val2, err2 := stringToInt("abc")
    if err2 != nil {
        fmt.Println(err2)
    } else {
        fmt.Println("成功:", val2)
    }
}
----

=== 可变参数

函数可以接受不定数量的参数，这称为可变参数。

[source, Go]
----
package main

import "fmt"

// sum 函数可以接受任意数量的 int 参数
func sum(nums ...int) {
    fmt.Print(nums, " -> ")
    total := 0
    for _, num := range nums {
        total += num
    }
    fmt.Println(total)
}

func main() {
    sum(1, 2)
    sum(1, 2, 3, 4)

    // 如果你有一个切片，可以使用 `...` 将其展开作为参数
    nums := []int{1, 2, 3, 4, 5}
    sum(nums...)
}
----

== 指针

指针保存了值的内存地址。使用指针，我们可以在函数内直接修改调用者作用域中的变量，避免在函数调用时进行大数据块的复制。

- `&` 操作符会生成一个指向其操作数的指针。
- `*` 操作符表示指针指向的底层值。

[source, Go]
----
package main

import "fmt"

// zeroval 通过值传递，函数内部对 i 的修改不影响外部
func zeroval(ival int) {
    ival = 0
}

// zeroptr 通过指针传递，函数内部的修改会影响到外部的原始变量
func zeroptr(iptr *int) {
    *iptr = 0 // 使用 * 解引用，修改指针指向地址的值
}

func main() {
    i := 1
    fmt.Println("初始值:", i)

    zeroval(i)
    fmt.Println("zeroval 后:", i) // i 的值没有改变

    zeroptr(&i) // 使用 & 获取 i 的内存地址
    fmt.Println("zeroptr 后:", i) // i 的值被改变为0

    fmt.Println("i 的指针地址是:", &i)
}
----

== 方法与接口

=== 方法 (Method)

方法是带有特殊“接收者”参数的函数。接收者可以是值类型或指针类型。方法提供了一种类似面向对象编程中“类”的行为。

[source, Go]
----
package main

import "fmt"

type Rect struct {
    width, height int
}

// area 方法有一个名为 r，类型为 *Rect 的接收者
func (r *Rect) area() int {
    return r.width * r.height
}

// perim 方法有一个名为 r，类型为 Rect 的接收者
func (r Rect) perim() int {
    return 2*r.width + 2*r.height
}

func main() {
    r := Rect{width: 10, height: 5}

    // 调用方法
    fmt.Println("面积: ", r.area())
    fmt.Println("周长: ", r.perim())

    rp := &r
    fmt.Println("面积 (通过指针): ", rp.area())
    fmt.Println("周长 (通过指针): ", rp.perim())
}
----

=== 接口 (Interface)

接口是定义了一组方法签名的类型。一个类型只要实现了接口中定义的所有方法，就被认为是“实现”了这个接口。这种实现是隐式的，无需像Java一样使用`implements`关键字。

[source, Go]
----
package main

import (
    "fmt"
    "math"
)

// 定义一个几何体接口
type Geometry interface {
    area() float64
    perim() float64
}

// 定义 Circle 和 Rect 类型
type Circle struct {
    radius float64
}
type Rect struct {
    width, height float64
}

// 为 Circle 实现 Geometry 接口
func (c Circle) area() float64 {
    return math.Pi * c.radius * c.radius
}
func (c Circle) perim() float64 {
    return 2 * math.Pi * c.radius
}

// 为 Rect 实现 Geometry 接口
func (r Rect) area() float64 {
    return r.width * r.height
}
func (r Rect) perim() float64 {
    return 2*r.width + 2*r.height
}

// measure 函数接收任何实现了 Geometry 接口的类型
func measure(g Geometry) {
    fmt.Println(g)
    fmt.Println("面积:", g.area())
    fmt.Println("周长:", g.perim())
}

func main() {
    c := Circle{radius: 5}
    r := Rect{width: 3, height: 4}

    // Circle 和 Rect 都实现了 Geometry 接口，所以可以作为 measure 函数的参数
    measure(c)
    measure(r)
}
----

== Go 并发

并发是 Go 语言的核心特性之一。它通过 Goroutine 和 Channel 来实现。

=== Goroutine

Goroutine 是由 Go 运行时管理的轻量级线程。使用 `go` 关键字即可启动一个新的 Goroutine。

[source, Go]
----
package main

import (
    "fmt"
    "time"
)

func say(s string) {
    for i := 0; i < 3; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    // 启动一个新的 Goroutine
    go say("world")
    
    // 当前 Goroutine (main)
    say("hello")
    
    // 等待一段时间，让 "world" Goroutine 有机会执行完
    time.Sleep(500 * time.Millisecond) 
    // 如果没有这句等待，main 函数会立即结束，可能导致 "world" 没机会打印
}
----

=== Channel

Channel 是用于在 Goroutine 之间传递数据的管道。它是实现并发同步的重要工具。

[source, Go]
----
package main

import "fmt"

func main() {
    // 创建一个可以传递 string 类型数据的 channel
    messages := make(chan string)

    // 启动一个 Goroutine，向 channel 发送数据
    go func() { 
        messages <- "ping" // 使用 <- 操作符发送数据
    }()

    // 从 channel 接收数据
    // 这个接收操作是阻塞的，直到有数据被发送进来
    msg := <-messages
    fmt.Println(msg)
}
----

=== Select

`select` 语句可以让一个 Goroutine 同时等待多个通信操作。`select` 会阻塞，直到其中一个 `case` 可以运行，然后它就执行那个 `case`。

[source, Go]
----
package main

import (
    "fmt"
    "time"
)

func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 <- "two"
    }()

    // select 会等待 c1 和 c2 的响应
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("received", msg1)
        case msg2 := <-c2:
            fmt.Println("received", msg2)
        }
    }
}
----
