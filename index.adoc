= Go Study Notes
Author whoyiming <whoyiming@outlook.com>
:doctype: book
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectnums:
:sectid:
:icons: font

[preface]
== 引言

此文档是关于学习Go语言所做的笔记，方便后续复习，温故而知新。

== Go 语言简介

=== 什么是Go

Go是由 Google 主导开发的静态类型、编译型编程语言，于 2009 年开源，设计目标是解决大型软件开发中的效率、复杂度与并发难题，核心哲学是 “简洁、高效、实用”。

** 极简设计：语法精简，移除冗余特性（如继承、复杂泛型早期缺失），用 “组合” 替代 “继承”，代码可读性高，学习成本低（例如强制统一格式的go fmt工具，避免风格争议）。

** 高性能：编译为机器码，执行效率接近 C 语言，远超解释型语言（如 Python）；启动速度极快（毫秒级），内存占用低，适合高性能服务场景。

** 原生并发：通过goroutine（轻量级线程，开销仅为操作系统线程的 1/100~1/10，单机可轻松创建百万级并发）和channel（通信管道）简化并发编程，从语言层面解决多核时代的并发难题。

** 平衡开发效率与可靠性：静态类型确保编译时错误检查（比动态语言更可靠），同时内置垃圾回收（GC）避免手动内存管理（比 C/C++ 更高效），开发效率接近动态语言。

=== Go 与 Java Python 的对比及其生态与场景

|===
| 维度       | Go                             | Java                             | Python                             
| 执行方式   | 编译型（直接生成机器码）| 编译型（字节码，依赖 JVM）| 解释型（依赖 Python 解释器）
| 启动速度   | 极快（毫秒级，单一二进制文件）| 较慢（JVM 预热耗时，秒级）| 中等（解释器启动快，但执行慢）
| 运行时性能 | 接近 C（CPU 密集型表现优异）| 优秀（JIT 优化后接近原生）| 较差（解释执行，比前两者慢 10-100 倍）
| 内存占用   | 低（无 JVM overhead）| 中高（JVM 本身占用内存）| 中（解释器 + 动态类型开销）
|===

|===
| 领域           | Go 擅长                                  | Java 擅长                                  | Python 擅长                                  
| 云原生 / 分布式 | Docker、K8s、Etcd、微服务                 | 分布式框架（Dubbo、Spring Cloud）| 边缘脚本、监控工具                           
| 企业级应用     | 轻量微服务（如字节跳动推荐系统）| 大型业务系统（银行、电商核心系统）| 内部工具、数据分析后台                       
| 移动开发       | 跨平台工具（如 Flutter 引擎）| 安卓应用（官方开发语言）| 无（仅辅助脚本）
| 数据科学 / AI  | 高性能计算引擎（如 TensorFlow 部分模块）| 机器学习框架（如 H2O）| 数据分析（Pandas）、AI（PyTorch/TensorFlow） 
| 工具开发       | 命令行工具（Terraform、Prometheus）| 企业级工具（Jenkins）| 自动化脚本、爬虫                             
|===

=== Go的前世今生

学习一门语言，要了解其前世今生，历史与现状，才能对一门语言有更加深入的理解。了解Go 语言是怎么诞生的，就能清晰知道Go 是为了解决什么问题，了解现状，就能知道语言发展经历到了什么阶段，能解决多大的问题。

Go 语言的创始人有三位，分别是图灵奖获得者、C 语法联合发明人、Unix 之父肯·汤普森（Ken Thompson），Plan 9 操作系统领导者、UTF-8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）。

image::images/93e91ef659a99c1e37d1fd54a8655375.webp[title="Go语言之父们（从左到右分别是Robert Griesemer、Rob Pike和Ken Thompson）"]

Go 诞生于一次研讨，三位大牛交换了关于设计一门新编程语言的想法。

当时，他们在谷歌内部使用的是 +++ C++ +++ 语言来构建各种系统，但 +++ C++ +++ 有着巨大的复杂性、编译构建慢、编写服务端不容易且对并发支持不足。三位大牛都觉得不方便，随即一拍即合，有了设计新语言的想法。新语言需要有简洁、高效、让人使用方便，且满足未来硬件发展趋势和大规模网络服务的程序。由此，Go语言的雏形便出现。随着三人想法的落地，再到社区运营更多人的参与，现在Go语言已经是一门在云原生、网络、企业级应用等方面有着足够竞争力的语言。同时，Go语言也在不断加入新特性，保证语言的活力。

== Go 环境配置

以下是windows环境安装Go语言。

访问 https://golang.google.cn/ （有可能打不开） 或者 https://go.dev/dl/ 。找到windows的包，下载安装版，在弹出的对话框中选择合适的目录进行安装。

image::images/2025-11-22-110052.png[]

如装在 C:\Go\Go1.25.4 ，其结构是

image:images/2025-11-22-110735.png[]

在终端中输入 go version 得到 go version go1.25.4 windows/amd64 ，便安装成功。

image:images/2025-11-23-102458.png[]

[CAUTION]
安装成功后，要重新启动终端，系统中设置的环境变量才会生效

== helloworld

创建一个文件夹 gocodes 写的代码。进入 gocodes，创建一个fisrtgo的文件夹，用于写第一个Go语言代码，进入firstgo，再创建一个hello.go的文件，用记事本打开，输入

[source, Go]
```
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
```

在终端上运行go run hello.go 得到 ** Hello, World!**

image:images/2025-11-23-101522.png[]

=== 基本程序结构

* package main   // 包，表面代码所在的模块（包），通常使用单个的小写字母命名。main包在Go中是一个特殊的包，整个 Go 程序中仅允许存在一个名为 main 的包。
* import "fmt"  // import引入fmt包，fmt 包实现了格式化 IO（输入/输出）的函数。
* func main()  // 程序开始执行的函数，函数内容用大括号包裹。当运行一个可执行的Go程序的时候，所有代码从此此处开始。
* fmt.Println("Hello, World!") // 使用fmt.Println方法，进行输出。

=== 与java的对比

|===
| 对比维度 | Go 语言（基于示例代码） | Java 语言（对应 Hello World 实现）

| 完整代码示例
| [source,go]
----
package main

import "fmt"

func main() {
    fmt.Println("hello, world")
}
----
| [source,java]
----
// 若声明包，需与目录结构一致（示例省略包声明）
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello, world");
    }
}
----

| 包声明规则
| 入口程序必须声明为 `package main`（固定要求），非入口包可自定义包名
| 包声明可选（无包声明则为默认包），**公共类名必须与文件名一致**（大小写敏感）

| 导入语句
| 直接导入依赖包路径（如 `import "fmt"`），支持批量导入（用 `()` 包裹多个包）
| 导入格式为 `import 包路径`（如 `import java.util.List`），`java.lang` 包（含 `System`）默认导入，无需显式声明

| 程序入口
| 入口是 `main` 包下的 `main()` 函数：
- 无参数、无返回值
- 无需修饰符（默认可见性）
| 入口是 **公共类** 下的 `main` 静态方法：
- 必须是 `public static void main(String[] args)`
- 需通过类名关联（运行时指定类名）

| 输出方式
| 使用标准库 `fmt` 包的 `Println()` 函数（格式化输出常用）
| 使用 `System.out.println()`（`System` 是 `java.lang` 包的类，`out` 是静态成员，`println()` 是实例方法）

| 编译与运行机制
| 1. 编译：`go build` 生成 **原生二进制文件**（跨平台需指定 `GOOS`/`GOARCH`）
2. 运行：直接执行二进制文件，或 `go run` 一键编译运行
| 1. 编译：`javac` 生成 `.class` 字节码文件
2. 运行：`java 类名` 由 JVM 解释字节码（跨平台依赖 JVM）

| 语法简洁性
| 无类、接口等面向对象语法，样板代码极少（仅3行核心逻辑）
| 必须用类包裹代码，需显式声明访问修饰符（`public`）和静态修饰符（`static`），样板代码较多

|===

- Go 以 **简洁、高效、原生编译** 为核心，弱化面向对象，更注重工程实用性和并发性能；
- Java 以 **强类型、面向对象、跨平台** 为核心，语法严谨，生态成熟，适合需要复杂架构设计的大型应用；
- 从 Hello World 就能看出：Go 追求“少即是多”，Java 追求“规范与扩展性”。

=== 加点复杂度

如果想要打印由终端输入的参数该怎么做呢？

在fisrtgo文件下创建一个printenv.go的文件

[source, Go]
```
package main

import (
	"fmt"
	"os"
)

func main() {
	if len(os.Args) > 1 {
		fmt.Println("Hello", os.Args[1])
	}
}
```

在终端下输入  go run .\printenv.go master

image:images/2025-11-23-111917.png[]

[TIP]
windows会默认隐藏拓展名，因此我们需要设置显示拓展名，如图所示进行设置

image:images/2025-11-22-113000.png[]

== Go 的基础语法

=== 数据类型

|===
| 类型分类       | 具体类型            | 说明

| 数值型         
| int（随系统位数）、int8/16/32/64   
| 有符号整数（int 在 32 位系统是 32 位，64 位系统是 64 位） 

|                
| uint（无符号）、uint8（byte）      
| 无符号整数（byte 是 uint8 的别名） 

|                
| float32、float64                  
| 浮点数（默认用 float64，精度更高），float32的精度约6-7位，float64的精度约 15-17 位

|                
| complex64、complex128             
| 复数（实部+虚部，如 `3+4i`）         

| 布尔型         
| bool                              
| 取值 true/false（不能用 0/1 替代）   

| 字符串         
| string                            
| 不可变字符序列（UTF-8 编码）         

| 字符型         
| rune                              
| Unicode 码点（int32 的别名，用于处理中文等多字节字符） 

|===

[source, Go]
----
package main

import "fmt"

func main() {
    var a int = 10          // 通用整数（随系统）
    var b uint8 = 255       // 无符号8位，最大值255（赋值256会编译错误）
    var c int64 = 9223372036854775807 // int64最大值
    fmt.Println("int:", a, "uint8:", b, "int64:", c) // 输出：int: 10 uint8: 255 int64: 9223372036854775807

    var f1 float32 = 3.1415926 // 32位浮点，精度有限
    f2 := 2.718281828459045    // 短变量声明，默认float64
    fmt.Println("float32:", f1, "float64:", f2) // 输出：float32: 3.1415925 float64: 2.718281828459045
    
    // 注意：浮点数精度问题
    fmt.Println("0.1 + 0.2 =", 0.1+0.2) // 输出：0.1 + 0.2 = 0.30000000000000004（非0.3）

    var c1 complex64 = 3 + 4i    // 32位复数（实部3，虚部4）
    c2 := 5 + 6i                 // 短变量声明，默认complex128
    fmt.Println("complex64:", c1)                // 输出：complex64: (3+4i)
    fmt.Println("实部:", real(c2), "虚部:", imag(c2)) // 输出：实部: 5 虚部: 6

    var b1 bool = true  // 显式声明
    b2 := false         // 短变量声明
    b3 := b1 && b2      // 逻辑与（都真才真）→ false
    b4 := b1 || b2      // 逻辑或（任一真则真）→ true
    b5 := !b1           // 逻辑非（取反）→ false
    
    fmt.Println("b1:", b1, "b2:", b2) // 输出：b1: true b2: false
    fmt.Println("b3 (&&):", b3, "b4 (||):", b4, "b5 (!):", b5) // 输出：b3 (&&): false b4 (||): true b5 (!): false
    
    // 条件判断（常用场景）
    if b1 {
        fmt.Println("b1 is true")
    } else {
        fmt.Println("b1 is false")
    }


    var s1 string = "Hello, Go!" // 双引号定义
	s2 := "Hello\nWorld"         // 支持转义（\n换行）
	s3 := `line1
	line2
	line3` // 反引号多行字符串（不转义）
	s4 := s1 + " " + s2 // 字符串拼接（+号）

	fmt.Println("s1:", s1) // 输出：s1: Hello, Go!
	fmt.Println("s2:", s2) // 输出：s2: Hello
	//      World
	fmt.Println("s3:", s3) // 输出：s3: line1
	//      line2
	//      line3
	fmt.Println("拼接后s4:", s4) // 输出：拼接后s4: Hello, Go! Hello
	//      World
	fmt.Println("s1长度（字节数）:", len(s1))      // 输出：10（每个ASCII字符占1字节）
	fmt.Println("\"Go语言\"长度:", len("Go语言")) // 输出：8（Go占2字节，中文"语""言"各占3字节）
}
----

=== 变量

Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。

声明变量的一般形式是使用 var 关键字：var param type，也可以一次声明多个变量：var param1，param2 type

[source, Go]
```
package main
import "fmt"
func main() {
    var a string = "hello"
    fmt.Println(a)

    var b, c int = 1, 2
    fmt.Println(b, c)
}
```

如果没有显示的为变量赋值，Go 编译器会为变量赋予这个类型的零值：
var a int // a的初值为int类型的零值：0

|===
|内置原生类型 |默认值（零值）

|所有整数类型 
|0

|浮点类型
|0.0

|布尔类型
|false

|字符串类型
|""

|指针、接口、切片、channel、map和函数类型
|nil
|===

变量声明块（block）的语法形式：

[source, Go]
```
var (
    a int = 128
    b int8 = 6
    s string = "hello"
    c rune = 'A'
    t bool = true
)

var (
    a, b, c int = 5, 6, 7
    c, d, e rune = 'C', 'D', 'E'
) 
```

两种变量声明语法糖：

1. 省略类型信息的声明：
* var a, b, c = 12, 'A', "hello"

2. 短变量声明：
[source, Go]
```
a := 12
b := 'A'
c := "hello"

a, b, c := 12, 'A', "hello"
```

=== 常量

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。在程序运行时，不会被修改的量。其定义格式为：const identifier [type] = value。

[source, Go]
```
package main

import "fmt"

func main() {
   const LENGTH int = 20
   const WIDTH int = 15   
   var area int
   const a, b, c = 1, false, "str" 

   area = LENGTH * WIDTH
   fmt.Println("面积为 : ", area)
   
   fmt.Println(a, b, c)   
}
```

== 运算符

=== 算术运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 基础算术运算
	a, b := 10, 3
	fmt.Println("a + b =", a+b)   // 13
	fmt.Println("a - b =", a-b)   // 7
	fmt.Println("a * b =", a*b)   // 30
	fmt.Println("a / b =", a/b)   // 3（整数除法舍弃小数）
	fmt.Println("a % b =", a%b)   // 1（余数）
	fmt.Println("-a % b =", -a%b) // -1（符号与被除数一致）

	// 浮点数运算
	f1, f2 := 10.0, 3.0
	fmt.Println("f1 / f2 =", f1/f2) // 3.3333333333333335

	// 字符串拼接（仅 + 支持）
	s1, s2 := "Go", "Lang"
	fmt.Println("s1 + s2 =", s1+s2) // GoLang

	// 自增自减（只能独立语句，不能赋值）
	i, j := 5, 5
	i++ // 正确：i = 6
	j-- // 正确：j = 4
	// fmt.Println(i++)  // 错误：不能作为表达式使用
	// k := i++          // 错误：不能赋值
	fmt.Println("i =", i, "j =", j) // 6 4
}
----

=== 赋值运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 基础赋值
	var x int = 10
	x = 20
	fmt.Println("x =", x) // 20

	// 复合赋值
	y := 10
	y += 5  // y = 10 + 5 = 15
	y *= 2  // y = 15 * 2 = 30
	y %= 7  // y = 30 % 7 = 2
	fmt.Println("y =", y) // 2

	// 位运算复合赋值
	z := 0b1010 // 10（二进制）
	z <<= 2     // 左移2位 → 0b101000 = 40
	fmt.Printf("z <<= 2 → %d（二进制：%b）\n", z, z) // 40（101000）
}
----

=== 比较运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 数值比较
	m, n := 10, 20
	fmt.Println("m == n?", m == n) // false
	fmt.Println("m < n?", m < n)   // true
	fmt.Println("m >= n?", m >= n) // false

	// 字符串比较（按Unicode码点顺序）
	s1, s2 := "apple", "banana"
	s3 := "apple"
	fmt.Println("s1 == s3?", s1 == s3) // true
	fmt.Println("s1 < s2?", s1 < s2)   // true（'a' 的码点 < 'b'）

	// 布尔值比较
	b1, b2 := true, false
	fmt.Println("b1 != b2?", b1 != b2) // true

	// 指针比较（指向同一变量则相等）
	p1 := &m
	p2 := &m
	p3 := &n
	fmt.Println("p1 == p2?", p1 == p2) // true
	fmt.Println("p1 == p3?", p1 == p3) // false

	// 错误示例：不同类型不能直接比较
	// var num int = 10
	// var f float64 = 10.0
	// fmt.Println(num == f) // 编译错误：int 和 float64 不兼容
}
----

=== 逻辑运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 基础逻辑运算
	a, b := true, false
	fmt.Println("a && b =", a && b) // false（且：都为true才true）
	fmt.Println("a || b =", a || b) // true（或：任一为true则true）
	fmt.Println("!a =", !a)         // false（非：取反）

	// 短路特性演示
	x, y := 10, 20

	// 逻辑与短路：左为false，右表达式（y++）不执行
	if x > 100 && autoincrement(y) > 0 {
		fmt.Println("逻辑与执行")
	}
	fmt.Println("y =", y) // 20（y++未执行）

	// 逻辑或短路：左为true，右表达式（x++）不执行
	if x < 20 || autoincrement(x) > 0 {
		fmt.Println("逻辑或执行")
	}
	fmt.Println("x =", x) // 10（x++未执行）
}

func autoincrement(val int) int {
	return val + 1
}
----

=== 位运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 定义8位无符号整数（便于观察二进制）
	var a uint8 = 0b1010 // 10（十进制）
	var b uint8 = 0b0110 // 6（十进制）

	// 按位与（&）：仅对应位都为1时为1
	fmt.Printf("a & b = %d（二进制：%08b）\n", a&b, a&b) // 2（00000010）

	// 按位或（|）：对应位任一为1时为1
	fmt.Printf("a | b = %d（二进制：%08b）\n", a|b, a|b) // 14（00001110）

	// 按位异或（^）：对应位不同时为1
	fmt.Printf("a ^ b = %d（二进制：%08b）\n", a^b, a^b) // 12（00001100）

	// 按位取反（^单目）：0→1，1→0（uint8 0b1010 → 0b11110101）
	fmt.Printf("^a = %d（二进制：%08b）\n", ^a, ^a) // 245（11110101）

	// 左移（<<）：左移2位 → 0b101000 = 40
	fmt.Printf("a << 2 = %d（二进制：%08b）\n", a<<2, a<<2) // 40（00101000）

	// 右移（>>）：右移1位 → 0b0101 = 5
	fmt.Printf("a >> 1 = %d（二进制：%08b）\n", a>>1, a>>1) // 5（00000101）

	// 有符号右移（补符号位）
	var c int8 = -10                                  // 二进制：11110110（补码）
	fmt.Printf("c >> 1 = %d（二进制：%08b）\n", c>>1, c>>1) // -5（11111011）
}
----

=== 其他常用运算符

[source, Go]
----
package main

import "fmt"

func main() {
	// 遍历切片
	slice := []string{"a", "b", "c"}
	for idx, val := range slice {
		fmt.Printf("切片索引：%d，值：%s\n", idx, val) // 0:a, 1:b, 2:c
	}

	// 遍历字符串（返回字节索引和Unicode码点）
	str := "Go语言"
	for idx, char := range str {
		fmt.Printf("字符串索引：%d，字符：%c（Unicode：%d）\n", idx, char, char)
		// 0:G(71), 1:o(111), 2:语(35821), 5:言(35328)（中文字符占3字节）
	}

	// 遍历map（返回键和值，无序）
	m := map[string]int{"a": 1, "b": 2}
	for key, val := range m {
		fmt.Printf("map键：%s，值：%d\n", key, val) // a:1, b:2（顺序不固定）
	}
}
----

== Go 流程控制

=== if-else 条件语句

[source, Go]
----
package main

import "fmt"

func main() {
	// 示例1：基础if-else
	score := 85
	if score >= 90 {
		fmt.Println("优秀")
	} else if score >= 70 {
		fmt.Println("良好")
	} else {
		fmt.Println("及格/不及格")
	}

	// 示例2：if初始化语句（推荐用法）
	if age := 22; age >= 18 { // age仅在if-else内有效
		fmt.Println("成年")
	} else {
		fmt.Println("未成年")
	}
}
----

=== for 循环

Go 没有while、do-while，所有循环都用for实现，语法灵活，覆盖三种常见场景。

[source, Go]
----
package main

import "fmt"

func main() {
    // 1. 基本的 for 循环 (类似 C/Java)
    sum := 0
    for i := 0; i < 10; i++ {
        sum += i
    }
    fmt.Println("0到9的和是:", sum)

    // 2. 省略初始化和后置语句 (类似 while)
    n := 1
    for n < 100 {
        n *= 2
    }
    fmt.Println("大于100的最小2的幂是:", n)

    // 2. 无限循环 (需要 break 或 return 退出)
    // for {
    //     fmt.Println("这是一个无限循环，请手动停止程序")
    // }
    
    // 3. for range 遍历 (非常常用)
    s := "Go语言"
    for index, char := range s {
        // 注意 index 是字节位置，char 是 rune 类型
        fmt.Printf("在字节位置 %d 的字符是 %c\n", index, char)
    }
}
----

=== switch 分支语句

Go 的 `switch` 非常灵活，它自动为每个 `case` 添加 `break`，匹配逻辑也更强大。

[source, Go]
----
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    // 1. 基本的 switch
    fmt.Print("Go 运行在 ")
    switch os := runtime.GOOS; os {
    case "darwin":
        fmt.Println("OS X.")
    case "linux":
        fmt.Println("Linux.")
    default:
        // os 在这里仍然可见
        fmt.Printf("%s.\n", os)
    }

    // 2. 无表达式的 switch (相当于 if-else)
    t := time.Now()
    switch {
    case t.Hour() < 12:
        fmt.Println("上午好!")
    case t.Hour() < 17:
        fmt.Println("下午好!")
    default:
        fmt.Println("晚上好!")
    }
    
    // 3. case 可以有多个值
    day := "saturday"
    switch day {
    case "saturday", "sunday":
        fmt.Println("是周末！")
    default:
        fmt.Println("是工作日。")
    }

    // 4：fallthrough（穿透）
	num := 2
	switch num {
	case 2:
		fmt.Println("匹配2")
		fallthrough // 强制穿透到下一个case
	case 3:
		fmt.Println("穿透到3") // 会执行
	default:
		fmt.Println("默认")
	}
}
----

== 复合数据类型

=== 数组 (Array)

数组是具有固定长度且包含相同类型元素的序列。

[source, Go]
----
package main

import "fmt"

func main() {
	//定义方式
	// 1. 声明并初始化（指定长度）
	var arr1 [3]int = [3]int{1, 2, 3}
	// 2. 短变量声明（自动推导类型）
	arr2 := [3]int{4, 5, 6}
	// 3. 自动推断长度（... 表示由初始化值决定）
	arr3 := [...]int{7, 8, 9}
	// 4. 部分初始化（未指定的元素为类型零值）
	arr4 := [5]string{"a", "b", 3: "d"} // 索引 0:a,1:b,2:"",3:d,4:""
	//在Go语言中，声明了一个变量或参数没有使用，编译器会报错。
	fmt.Println(arr1, arr2, arr3, arr4)

	//基本操作
	arr := [3]int{10, 20, 30}

	// 1. 索引访问（0 开始）
	fmt.Println(arr[0]) // 输出 10
	arr[1] = 200        // 修改元素

	// 2. 遍历（for 循环）
	for i := 0; i < len(arr); i++ {
		fmt.Printf("索引 %d: %d\n", i, arr[i])
	}

	// 3. 遍历（for range，推荐）
	for idx, val := range arr {
		fmt.Printf("idx: %d, val: %d\n", idx, val)
	}
}

----

=== 切片 (Slice)

* 动态长度的 “动态数组”，基于数组实现（底层引用一个数组）
* 引用类型（赋值 / 传参时仅拷贝引用，修改会影响原切片）
* 由 len（当前元素个数）和 cap（底层数组容量）描述
* 支持 append 扩容、切片截取（slice[low:high]）

[source, Go]
----
package main

import "fmt"

func main() {
	// 1. 声明切片（三种方式）
	var s1 []int                  // 空切片（len=0, cap=0）
	s2 := []string{"a", "b", "c"} // 直接初始化
	s3 := make([]float64, 3, 5)   // make(类型, 长度, 容量)，未初始化元素为零值

	fmt.Println("s1:", s1, "len:", len(s1), "cap:", cap(s1)) // s1: [] len: 0 cap: 0
	fmt.Println("s2:", s2, "len:", len(s2), "cap:", cap(s2)) // s2: [a b c] len: 3 cap: 3
	fmt.Println("s3:", s3, "len:", len(s3), "cap:", cap(s3)) // s3: [0 0 0] len: 3 cap: 5

	// 2. 切片截取（左闭右开，不修改原切片，共享底层数组）
	s4 := s2[1:3]              // 从 s2 截取索引 1~2（不含3）
	fmt.Println("s4:", s4)     // 输出：s4: [b c]
	s4[0] = "x"                // 修改截取切片，原切片也会变（共享底层数组）
	fmt.Println("修改后 s2:", s2) // 输出：修改后 s2: [a x c]

	// 3. append 扩容（容量不足时自动扩容，生成新底层数组）
	s5 := []int{1, 2}
	fmt.Println("s5 初始:", s5, "len:", len(s5), "cap:", cap(s5))  // [1 2] len:2 cap:2
	s5 = append(s5, 3, 4, 5)                                     // 追加元素，容量不足时扩容（通常翻倍）
	fmt.Println("s5 追加后:", s5, "len:", len(s5), "cap:", cap(s5)) // [1 2 3 4 5] len:5 cap:6

	// 4. 切片拷贝（copy(dst, src)，仅拷贝元素，不共享底层数组）
	src := []int{10, 20, 30}
	dst := make([]int, len(src))
	copy(dst, src)
	dst[0] = 999
	fmt.Println("原 src:", src)   // 输出：原 src: [10 20 30]
	fmt.Println("拷贝后 dst:", dst) // 输出：拷贝后 dst: [999 20 30]
}

----

=== Map

* Map 是一个无序的键值对集合，也称为哈希表或字典。
* 引用类型，必须通过 make 初始化（或直接字面量初始化）
* key 必须是可比较类型（如 int、string、bool，不能是切片、map、函数）
* 支持增删改查，通过 for range 遍历（无序）

[source, Go]
----
package main

import "fmt"

func main() {
	// 1. 初始化 map（两种方式）
	m1 := make(map[string]int) // 空 map
	m2 := map[string]string{
		"name": "张三",
		"age":  "25",
		"city": "北京",
	}

	// 2. 新增/修改元素（key 存在则修改，不存在则新增）
	m1["math"] = 90
	m1["english"] = 85
	m2["age"] = "26"       // 修改已有 key
	fmt.Println("m1:", m1) // 输出：m1: map[english:85 math:90]
	fmt.Println("m2:", m2) // 输出：m2: map[age:26 city:北京 name:张三]

	// 3. 查询元素（第二个返回值表示 key 是否存在）
	score, ok := m1["math"]
	if ok {
		fmt.Println("math 成绩:", score) // 输出：math 成绩: 90
	} else {
		fmt.Println("math 成绩不存在")
	}

	// 4. 删除元素（delete(map, key)，key 不存在则无操作）
	delete(m2, "city")
	fmt.Println("m2 删除 city 后:", m2) // 输出：m2 删除 city 后: map[age:26 name:张三]

	// 5. 遍历 map（无序，每次遍历顺序可能不同）
	fmt.Println("遍历 m1:")
	for k, v := range m1 {
		fmt.Printf("key: %s, value: %d\n", k, v)
	}

	// 6. map 是引用类型（拷贝后修改会影响原 map）
	m3 := m1
	m3["english"] = 95
	fmt.Println("原 m1:", m1)   // 输出：原 m1: map[english:95 math:90]
	fmt.Println("拷贝后 m3:", m3) // 输出：拷贝后 m3: map[english:95 math:90]
}

----

=== 结构体 (Struct)

* 自定义复合类型，可包含多个不同类型的字段（类似其他语言的 “类”）
* 值类型（默认），支持定义方法（绑定到结构体的函数）
* 用于封装数据，实现面向对象的核心特性（如封装、组合）

[source, Go]
----
package main

import "fmt"

// 1. 定义结构体（首字母大写表示可导出，供其他包使用，字段首字母大写表示可导出，供其他包使用，字段首字母小写表示包内私有，不导出）
type Person struct {
	Name string
	Age  int
	Addr string
}

// 2. 定义结构体方法（值接收者：修改不会影响原结构体）
func (p Person) SayHello() {
	fmt.Printf("大家好，我是 %s，今年 %d 岁\n", p.Name, p.Age)
}

// 3. 指针接收者：修改会影响原结构体（推荐用于大结构体，避免拷贝）
func (p *Person) GrowUp() {
	p.Age++ // 等价于 (*p).Age++
}

func main() {
	// 4. 创建结构体实例（三种方式）
	p1 := Person{"张三", 25, "北京"}      // 按字段顺序初始化
	p2 := Person{Name: "李四", Age: 30} // 指定字段初始化（未指定字段为零值）
	p3 := new(Person)                 // new 返回指针 (*Person)
	p3.Name = "王五"
	p3.Age = 28

	fmt.Println("p1:", p1) // 输出：p1: {张三 25 北京}
	fmt.Println("p2:", p2) // 输出：p2: {李四 30 }（Addr 为零值 ""）
	fmt.Println("p3:", p3) // 输出：p3: &{王五 28 }（指针类型）

	// 5. 访问字段（指针结构体可直接通过 . 访问，无需解引用）
	fmt.Println("p3 姓名:", p3.Name) // 输出：p3 姓名: 王五

	// 6. 调用方法（值接收者和指针接收者均可直接调用，Go 自动转换）
	p1.SayHello() // 输出：大家好，我是 张三，今年 25 岁
	p3.GrowUp()   // 调用指针方法，修改原结构体年龄
	p3.SayHello() // 输出：大家好，我是 王五，今年 29 岁

	// 7. 结构体嵌套（实现“组合”，类似继承）
	type Student struct {
		Person // 嵌套结构体（匿名字段，继承 Person 的字段和方法）
		Score  int
	}
	stu := Student{Person: Person{Name: "赵六", Age: 20}, Score: 95}
	fmt.Println("学生姓名:", stu.Name) // 直接访问嵌套字段
	stu.SayHello()                 // 调用嵌套结构体的方法
}

----

== Go 函数

在Go中，函数是“一等公民”，意味着它们可以像任何其他值一样被传递、赋值。

=== 多返回值

Go函数可以返回任意数量的值。这在Go中被广泛用于返回结果和错误信息。

[source, Go]
----
package main

import (
    "fmt"
    "strconv"
)

// stringToInt 将字符串转换为整数，同时返回结果和一个错误信息
func stringToInt(s string) (int, error) {
    i, err := strconv.Atoi(s)
    if err != nil {
        // 如果转换出错，返回0和错误信息
        return 0, fmt.Errorf("转换失败: %v", err)
    }
    // 成功则返回转换后的整数和 nil
    return i, nil
}

func main() {
    val1, err1 := stringToInt("123")
    if err1 != nil {
        fmt.Println(err1)
    } else {
        fmt.Println("成功:", val1)
    }
    
    val2, err2 := stringToInt("abc")
    if err2 != nil {
        fmt.Println(err2)
    } else {
        fmt.Println("成功:", val2)
    }
}
----

=== 可变参数

函数可以接受不定数量的参数，这称为可变参数。

[source, Go]
----
package main

import "fmt"

// sum 函数可以接受任意数量的 int 参数
func sum(nums ...int) {
    fmt.Print(nums, " -> ")
    total := 0
    for _, num := range nums {
        total += num
    }
    fmt.Println(total)
}

func main() {
    sum(1, 2)
    sum(1, 2, 3, 4)

    // 如果你有一个切片，可以使用 `...` 将其展开作为参数
    nums := []int{1, 2, 3, 4, 5}
    sum(nums...)
}
----

== 指针

指针保存了值的内存地址。使用指针，我们可以在函数内直接修改调用者作用域中的变量，避免在函数调用时进行大数据块的复制。

- `&` 操作符会生成一个指向其操作数的指针。
- `*` 操作符表示指针指向的底层值。

[source, Go]
----
package main

import "fmt"

// zeroval 通过值传递，函数内部对 i 的修改不影响外部
func zeroval(ival int) {
    ival = 0
}

// zeroptr 通过指针传递，函数内部的修改会影响到外部的原始变量
func zeroptr(iptr *int) {
    *iptr = 0 // 使用 * 解引用，修改指针指向地址的值
}

func main() {
    i := 1
    fmt.Println("初始值:", i)

    zeroval(i)
    fmt.Println("zeroval 后:", i) // i 的值没有改变

    zeroptr(&i) // 使用 & 获取 i 的内存地址
    fmt.Println("zeroptr 后:", i) // i 的值被改变为0

    fmt.Println("i 的指针地址是:", &i)
}
----

== 方法与接口

=== 方法 (Method)

方法是带有特殊“接收者”参数的函数。接收者可以是值类型或指针类型。方法提供了一种类似面向对象编程中“类”的行为。

[source, Go]
----
package main

import "fmt"

type Rect struct {
    width, height int
}

// area 方法有一个名为 r，类型为 *Rect 的接收者
func (r *Rect) area() int {
    return r.width * r.height
}

// perim 方法有一个名为 r，类型为 Rect 的接收者
func (r Rect) perim() int {
    return 2*r.width + 2*r.height
}

func main() {
    r := Rect{width: 10, height: 5}

    // 调用方法
    fmt.Println("面积: ", r.area())
    fmt.Println("周长: ", r.perim())

    rp := &r
    fmt.Println("面积 (通过指针): ", rp.area())
    fmt.Println("周长 (通过指针): ", rp.perim())
}
----

=== 接口 (Interface)

接口是定义了一组方法签名的类型。一个类型只要实现了接口中定义的所有方法，就被认为是“实现”了这个接口。这种实现是隐式的，无需像Java一样使用`implements`关键字。

[source, Go]
----
package main

import (
    "fmt"
    "math"
)

// 定义一个几何体接口
type Geometry interface {
    area() float64
    perim() float64
}

// 定义 Circle 和 Rect 类型
type Circle struct {
    radius float64
}
type Rect struct {
    width, height float64
}

// 为 Circle 实现 Geometry 接口
func (c Circle) area() float64 {
    return math.Pi * c.radius * c.radius
}
func (c Circle) perim() float64 {
    return 2 * math.Pi * c.radius
}

// 为 Rect 实现 Geometry 接口
func (r Rect) area() float64 {
    return r.width * r.height
}
func (r Rect) perim() float64 {
    return 2*r.width + 2*r.height
}

// measure 函数接收任何实现了 Geometry 接口的类型
func measure(g Geometry) {
    fmt.Println(g)
    fmt.Println("面积:", g.area())
    fmt.Println("周长:", g.perim())
}

func main() {
    c := Circle{radius: 5}
    r := Rect{width: 3, height: 4}

    // Circle 和 Rect 都实现了 Geometry 接口，所以可以作为 measure 函数的参数
    measure(c)
    measure(r)
}
----

== Go 并发

并发是 Go 语言的核心特性之一。它通过 Goroutine 和 Channel 来实现。

=== Goroutine

Goroutine 是由 Go 运行时管理的轻量级线程。使用 `go` 关键字即可启动一个新的 Goroutine。

[source, Go]
----
package main

import (
    "fmt"
    "time"
)

func say(s string) {
    for i := 0; i < 3; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    // 启动一个新的 Goroutine
    go say("world")
    
    // 当前 Goroutine (main)
    say("hello")
    
    // 等待一段时间，让 "world" Goroutine 有机会执行完
    time.Sleep(500 * time.Millisecond) 
    // 如果没有这句等待，main 函数会立即结束，可能导致 "world" 没机会打印
}
----

=== Channel

Channel 是用于在 Goroutine 之间传递数据的管道。它是实现并发同步的重要工具。

[source, Go]
----
package main

import "fmt"

func main() {
    // 创建一个可以传递 string 类型数据的 channel
    messages := make(chan string)

    // 启动一个 Goroutine，向 channel 发送数据
    go func() { 
        messages <- "ping" // 使用 <- 操作符发送数据
    }()

    // 从 channel 接收数据
    // 这个接收操作是阻塞的，直到有数据被发送进来
    msg := <-messages
    fmt.Println(msg)
}
----

=== Select

`select` 语句可以让一个 Goroutine 同时等待多个通信操作。`select` 会阻塞，直到其中一个 `case` 可以运行，然后它就执行那个 `case`。

[source, Go]
----
package main

import (
    "fmt"
    "time"
)

func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 <- "two"
    }()

    // select 会等待 c1 和 c2 的响应
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("received", msg1)
        case msg2 := <-c2:
            fmt.Println("received", msg2)
        }
    }
}
----
